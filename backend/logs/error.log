{
  message: `Validation error: Passwords don't match at "body.Password confirmations"`,
  level: 'error',
  timestamp: '2025-02-17T18:41:59.511Z'
}
{
  message: `Validation error: Passwords don't match at "body.Password confirmations"`,
  level: 'error',
  timestamp: '2025-02-17T18:44:29.238Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:09:56.277Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:10:36.093Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:10:39.785Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:10:40.652Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:11:17.571Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:11:19.366Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:11:36.374Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:12:18.234Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:12:59.480Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:13:00.707Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:13:34.569Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:14:31.711Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:15:11.289Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:15:11.290Z'
}
{
  message: 'Error while creating account, email already exists.',
  level: 'error',
  timestamp: '2025-02-17T19:15:57.344Z'
}
{
  message: 'Email is already exists, try another email.',
  level: 'error',
  timestamp: '2025-02-17T19:15:57.346Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:16:05.282Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:16:05.283Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:17:19.331Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:17:19.333Z'
}
{
  message: '\n' +
    'Invalid `prisma.email.create()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\config\\email.ts:25:22\n' +
    '\n' +
    '  22 };\n' +
    '  23 const info = await transporter.sendMail(data);\n' +
    '  24 logger.info("Email sent successfully, id: " + info.messageId);\n' +
    '→ 25 await prisma.email.create({\n' +
    '       data: {\n' +
    '         email: "ebrahimsayed054@gmail.com",\n' +
    '         subject: "Email verification",\n' +
    '     +   id: String\n' +
    '       }\n' +
    '     })\n' +
    '\n' +
    'Argument `id` is missing.',
  level: 'error',
  timestamp: '2025-02-17T19:49:02.145Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findUnique()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\Auth\\Auth.Service.ts:81:36\n' +
    '\n' +
    '  78 }\n' +
    '  79 \n' +
    '  80 async sendEmailToken(Payload: any): Promise<any> {\n' +
    '→ 81   const user = await prisma.user.findUnique({\n' +
    '         where: {\n' +
    '           email: undefined,\n' +
    '       ?   id?: String,\n' +
    '       ?   AND?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   OR?: UserWhereInput[],\n' +
    '       ?   NOT?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   googleId?: StringNullableFilter | String | Null,\n' +
    '       ?   name?: StringFilter | String,\n' +
    '       ?   avatar?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationToken?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   emailVerified?: BoolFilter | Boolean,\n' +
    '       ?   password?: StringFilter | String,\n' +
    '       ?   passwordChangedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   passwordResetToken?: StringNullableFilter | String | Null,\n' +
    '       ?   passwordResetTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   role?: EnumRolesFilter | Roles,\n' +
    '       ?   isActive?: BoolFilter | Boolean,\n' +
    '       ?   twoFactorAuth?: BoolFilter | Boolean,\n' +
    '       ?   OTP?: StringNullableFilter | String | Null,\n' +
    '       ?   OTPExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   createdAt?: DateTimeFilter | DateTime,\n' +
    '       ?   updatedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   reviews?: ReviewListRelationFilter,\n' +
    '       ?   replies?: ReviewReplyListRelationFilter,\n' +
    '       ?   comments?: CommentListRelationFilter,\n' +
    '       ?   courses?: OrderListRelationFilter,\n' +
    '       ?   publishedCourses?: CourseListRelationFilter\n' +
    '         }\n' +
    '       })\n' +
    '\n' +
    'Argument `where` of type UserWhereUniqueInput needs at least one of `id` or `email` arguments. Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-17T19:56:52.581Z'
}
{
  message: 'Error while creating account, email already exists.',
  level: 'error',
  timestamp: '2025-02-17T19:57:48.123Z'
}
{
  message: 'Email is already exists, try another email.',
  level: 'error',
  timestamp: '2025-02-17T19:57:48.124Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findUnique()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\Auth\\Auth.Service.ts:81:36\n' +
    '\n' +
    '  78 }\n' +
    '  79 \n' +
    '  80 async sendEmailToken(Payload: any): Promise<any> {\n' +
    '→ 81   const user = await prisma.user.findUnique({\n' +
    '         where: {\n' +
    '           email: undefined,\n' +
    '       ?   id?: String,\n' +
    '       ?   AND?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   OR?: UserWhereInput[],\n' +
    '       ?   NOT?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   googleId?: StringNullableFilter | String | Null,\n' +
    '       ?   name?: StringFilter | String,\n' +
    '       ?   avatar?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationToken?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   emailVerified?: BoolFilter | Boolean,\n' +
    '       ?   password?: StringFilter | String,\n' +
    '       ?   passwordChangedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   passwordResetToken?: StringNullableFilter | String | Null,\n' +
    '       ?   passwordResetTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   role?: EnumRolesFilter | Roles,\n' +
    '       ?   isActive?: BoolFilter | Boolean,\n' +
    '       ?   twoFactorAuth?: BoolFilter | Boolean,\n' +
    '       ?   OTP?: StringNullableFilter | String | Null,\n' +
    '       ?   OTPExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   createdAt?: DateTimeFilter | DateTime,\n' +
    '       ?   updatedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   reviews?: ReviewListRelationFilter,\n' +
    '       ?   replies?: ReviewReplyListRelationFilter,\n' +
    '       ?   comments?: CommentListRelationFilter,\n' +
    '       ?   courses?: OrderListRelationFilter,\n' +
    '       ?   publishedCourses?: CourseListRelationFilter\n' +
    '         }\n' +
    '       })\n' +
    '\n' +
    'Argument `where` of type UserWhereUniqueInput needs at least one of `id` or `email` arguments. Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-17T20:00:41.893Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:08:37.469Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:09:38.883Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:10:25.411Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:10:29.890Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:10:36.738Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T20:11:14.267Z'
}
{
  message: 'Invalid or expired token',
  level: 'error',
  timestamp: '2025-02-17T20:11:14.269Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T20:12:19.773Z'
}
{
  message: 'Invalid or expired token',
  level: 'error',
  timestamp: '2025-02-17T20:12:19.774Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findUnique()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\Auth\\Auth.Service.ts:81:36\n' +
    '\n' +
    '  78 }\n' +
    '  79 \n' +
    '  80 async sendEmailToken(Payload: any): Promise<any> {\n' +
    '→ 81   const user = await prisma.user.findUnique({\n' +
    '         where: {\n' +
    '           email: undefined,\n' +
    '       ?   id?: String,\n' +
    '       ?   AND?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   OR?: UserWhereInput[],\n' +
    '       ?   NOT?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   googleId?: StringNullableFilter | String | Null,\n' +
    '       ?   name?: StringFilter | String,\n' +
    '       ?   avatar?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationToken?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   emailVerified?: BoolFilter | Boolean,\n' +
    '       ?   password?: StringFilter | String,\n' +
    '       ?   passwordChangedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   passwordResetToken?: StringNullableFilter | String | Null,\n' +
    '       ?   passwordResetTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   role?: EnumRolesFilter | Roles,\n' +
    '       ?   isActive?: BoolFilter | Boolean,\n' +
    '       ?   twoFactorAuth?: BoolFilter | Boolean,\n' +
    '       ?   OTP?: StringNullableFilter | String | Null,\n' +
    '       ?   OTPExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   createdAt?: DateTimeFilter | DateTime,\n' +
    '       ?   updatedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   reviews?: ReviewListRelationFilter,\n' +
    '       ?   replies?: ReviewReplyListRelationFilter,\n' +
    '       ?   comments?: CommentListRelationFilter,\n' +
    '       ?   courses?: OrderListRelationFilter,\n' +
    '       ?   publishedCourses?: CourseListRelationFilter\n' +
    '         }\n' +
    '       })\n' +
    '\n' +
    'Argument `where` of type UserWhereUniqueInput needs at least one of `id` or `email` arguments. Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-17T20:13:02.860Z'
}
{
  message: 'You are not allowed to use this endpoint',
  level: 'error',
  timestamp: '2025-02-17T20:19:54.242Z'
}
{
  message: "User's sesssion expired.",
  level: 'error',
  timestamp: '2025-02-18T11:37:55.036Z'
}
{
  message: 'Expired session, please login again',
  level: 'error',
  timestamp: '2025-02-18T11:37:55.038Z'
}
{
  message: "User's sesssion expired.",
  level: 'error',
  timestamp: '2025-02-18T11:39:19.370Z'
}
{
  message: 'Expired session, please login again',
  level: 'error',
  timestamp: '2025-02-18T11:39:19.371Z'
}
{
  message: 'Route: /api/v1/auth/ggg not found',
  level: 'error',
  timestamp: '2025-02-18T18:18:52.678Z'
}
{
  message: 'Email is already exists, try another email.',
  level: 'error',
  timestamp: '2025-02-18T18:19:09.823Z'
}
{
  message: 'Email is already exists, try another email.',
  level: 'error',
  timestamp: '2025-02-18T18:19:32.430Z'
}
