{
  message: `Validation error: Passwords don't match at "body.Password confirmations"`,
  level: 'error',
  timestamp: '2025-02-17T18:41:59.511Z'
}
{
  message: `Validation error: Passwords don't match at "body.Password confirmations"`,
  level: 'error',
  timestamp: '2025-02-17T18:44:29.238Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:09:56.277Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:10:36.093Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:10:39.785Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:10:40.652Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:11:17.571Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T19:11:19.366Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:11:36.374Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:12:18.234Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:12:59.480Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:13:00.707Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:13:34.569Z'
}
{
  message: 'Digest method not supported',
  level: 'error',
  timestamp: '2025-02-17T19:14:31.711Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:15:11.289Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:15:11.290Z'
}
{
  message: 'Error while creating account, email already exists.',
  level: 'error',
  timestamp: '2025-02-17T19:15:57.344Z'
}
{
  message: 'Email is already exists, try another email.',
  level: 'error',
  timestamp: '2025-02-17T19:15:57.346Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:16:05.282Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:16:05.283Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:17:19.331Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T19:17:19.333Z'
}
{
  message: '\n' +
    'Invalid `prisma.email.create()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\config\\email.ts:25:22\n' +
    '\n' +
    '  22 };\n' +
    '  23 const info = await transporter.sendMail(data);\n' +
    '  24 logger.info("Email sent successfully, id: " + info.messageId);\n' +
    '→ 25 await prisma.email.create({\n' +
    '       data: {\n' +
    '         email: "ebrahimsayed054@gmail.com",\n' +
    '         subject: "Email verification",\n' +
    '     +   id: String\n' +
    '       }\n' +
    '     })\n' +
    '\n' +
    'Argument `id` is missing.',
  level: 'error',
  timestamp: '2025-02-17T19:49:02.145Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findUnique()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\Auth\\Auth.Service.ts:81:36\n' +
    '\n' +
    '  78 }\n' +
    '  79 \n' +
    '  80 async sendEmailToken(Payload: any): Promise<any> {\n' +
    '→ 81   const user = await prisma.user.findUnique({\n' +
    '         where: {\n' +
    '           email: undefined,\n' +
    '       ?   id?: String,\n' +
    '       ?   AND?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   OR?: UserWhereInput[],\n' +
    '       ?   NOT?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   googleId?: StringNullableFilter | String | Null,\n' +
    '       ?   name?: StringFilter | String,\n' +
    '       ?   avatar?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationToken?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   emailVerified?: BoolFilter | Boolean,\n' +
    '       ?   password?: StringFilter | String,\n' +
    '       ?   passwordChangedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   passwordResetToken?: StringNullableFilter | String | Null,\n' +
    '       ?   passwordResetTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   role?: EnumRolesFilter | Roles,\n' +
    '       ?   isActive?: BoolFilter | Boolean,\n' +
    '       ?   twoFactorAuth?: BoolFilter | Boolean,\n' +
    '       ?   OTP?: StringNullableFilter | String | Null,\n' +
    '       ?   OTPExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   createdAt?: DateTimeFilter | DateTime,\n' +
    '       ?   updatedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   reviews?: ReviewListRelationFilter,\n' +
    '       ?   replies?: ReviewReplyListRelationFilter,\n' +
    '       ?   comments?: CommentListRelationFilter,\n' +
    '       ?   courses?: OrderListRelationFilter,\n' +
    '       ?   publishedCourses?: CourseListRelationFilter\n' +
    '         }\n' +
    '       })\n' +
    '\n' +
    'Argument `where` of type UserWhereUniqueInput needs at least one of `id` or `email` arguments. Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-17T19:56:52.581Z'
}
{
  message: 'Error while creating account, email already exists.',
  level: 'error',
  timestamp: '2025-02-17T19:57:48.123Z'
}
{
  message: 'Email is already exists, try another email.',
  level: 'error',
  timestamp: '2025-02-17T19:57:48.124Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findUnique()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\Auth\\Auth.Service.ts:81:36\n' +
    '\n' +
    '  78 }\n' +
    '  79 \n' +
    '  80 async sendEmailToken(Payload: any): Promise<any> {\n' +
    '→ 81   const user = await prisma.user.findUnique({\n' +
    '         where: {\n' +
    '           email: undefined,\n' +
    '       ?   id?: String,\n' +
    '       ?   AND?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   OR?: UserWhereInput[],\n' +
    '       ?   NOT?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   googleId?: StringNullableFilter | String | Null,\n' +
    '       ?   name?: StringFilter | String,\n' +
    '       ?   avatar?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationToken?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   emailVerified?: BoolFilter | Boolean,\n' +
    '       ?   password?: StringFilter | String,\n' +
    '       ?   passwordChangedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   passwordResetToken?: StringNullableFilter | String | Null,\n' +
    '       ?   passwordResetTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   role?: EnumRolesFilter | Roles,\n' +
    '       ?   isActive?: BoolFilter | Boolean,\n' +
    '       ?   twoFactorAuth?: BoolFilter | Boolean,\n' +
    '       ?   OTP?: StringNullableFilter | String | Null,\n' +
    '       ?   OTPExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   createdAt?: DateTimeFilter | DateTime,\n' +
    '       ?   updatedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   reviews?: ReviewListRelationFilter,\n' +
    '       ?   replies?: ReviewReplyListRelationFilter,\n' +
    '       ?   comments?: CommentListRelationFilter,\n' +
    '       ?   courses?: OrderListRelationFilter,\n' +
    '       ?   publishedCourses?: CourseListRelationFilter\n' +
    '         }\n' +
    '       })\n' +
    '\n' +
    'Argument `where` of type UserWhereUniqueInput needs at least one of `id` or `email` arguments. Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-17T20:00:41.893Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:08:37.469Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:09:38.883Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:10:25.411Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:10:29.890Z'
}
{
  message: 'Validation error: Required at "params"',
  level: 'error',
  timestamp: '2025-02-17T20:10:36.738Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T20:11:14.267Z'
}
{
  message: 'Invalid or expired token',
  level: 'error',
  timestamp: '2025-02-17T20:11:14.269Z'
}
{
  message: 'Invalid or expired token.',
  level: 'error',
  timestamp: '2025-02-17T20:12:19.773Z'
}
{
  message: 'Invalid or expired token',
  level: 'error',
  timestamp: '2025-02-17T20:12:19.774Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findUnique()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\Auth\\Auth.Service.ts:81:36\n' +
    '\n' +
    '  78 }\n' +
    '  79 \n' +
    '  80 async sendEmailToken(Payload: any): Promise<any> {\n' +
    '→ 81   const user = await prisma.user.findUnique({\n' +
    '         where: {\n' +
    '           email: undefined,\n' +
    '       ?   id?: String,\n' +
    '       ?   AND?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   OR?: UserWhereInput[],\n' +
    '       ?   NOT?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   googleId?: StringNullableFilter | String | Null,\n' +
    '       ?   name?: StringFilter | String,\n' +
    '       ?   avatar?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationToken?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   emailVerified?: BoolFilter | Boolean,\n' +
    '       ?   password?: StringFilter | String,\n' +
    '       ?   passwordChangedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   passwordResetToken?: StringNullableFilter | String | Null,\n' +
    '       ?   passwordResetTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   role?: EnumRolesFilter | Roles,\n' +
    '       ?   isActive?: BoolFilter | Boolean,\n' +
    '       ?   twoFactorAuth?: BoolFilter | Boolean,\n' +
    '       ?   OTP?: StringNullableFilter | String | Null,\n' +
    '       ?   OTPExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   createdAt?: DateTimeFilter | DateTime,\n' +
    '       ?   updatedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   reviews?: ReviewListRelationFilter,\n' +
    '       ?   replies?: ReviewReplyListRelationFilter,\n' +
    '       ?   comments?: CommentListRelationFilter,\n' +
    '       ?   courses?: OrderListRelationFilter,\n' +
    '       ?   publishedCourses?: CourseListRelationFilter\n' +
    '         }\n' +
    '       })\n' +
    '\n' +
    'Argument `where` of type UserWhereUniqueInput needs at least one of `id` or `email` arguments. Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-17T20:13:02.860Z'
}
{
  message: 'You are not allowed to use this endpoint',
  level: 'error',
  timestamp: '2025-02-17T20:19:54.242Z'
}
{
  message: "User's sesssion expired.",
  level: 'error',
  timestamp: '2025-02-18T11:37:55.036Z'
}
{
  message: 'Expired session, please login again',
  level: 'error',
  timestamp: '2025-02-18T11:37:55.038Z'
}
{
  message: "User's sesssion expired.",
  level: 'error',
  timestamp: '2025-02-18T11:39:19.370Z'
}
{
  message: 'Expired session, please login again',
  level: 'error',
  timestamp: '2025-02-18T11:39:19.371Z'
}
{
  message: 'Route: /api/v1/auth/ggg not found',
  level: 'error',
  timestamp: '2025-02-18T18:18:52.678Z'
}
{
  message: 'Email is already exists, try another email.',
  level: 'error',
  timestamp: '2025-02-18T18:19:09.823Z'
}
{
  message: 'Email is already exists, try another email.',
  level: 'error',
  timestamp: '2025-02-18T18:19:32.430Z'
}
{
  message: 'Incorrect email or password.',
  level: 'error',
  timestamp: '2025-02-18T18:45:21.837Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findUnique()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\Auth\\Auth.Service.ts:160:36\n' +
    '\n' +
    '  157 }\n' +
    '  158 \n' +
    '  159 async forgotPassword(Payload: string) {\n' +
    '→ 160   const user = await prisma.user.findUnique({\n' +
    '          where: {\n' +
    '            email: {\n' +
    '              email: "ebrahimsayed054@gmail.com"\n' +
    '            }\n' +
    '            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n' +
    '          }\n' +
    '        })\n' +
    '\n' +
    'Argument `email`: Invalid value provided. Expected String, provided Object.',
  level: 'error',
  timestamp: '2025-02-18T18:45:35.487Z'
}
{
  message: 'Route: /api/v1/auth/reset-password/9d24b9121b74212536fb579e3b6ba901df54b7bd21c9a292c18e29e71245581a not found',
  level: 'error',
  timestamp: '2025-02-18T18:56:57.883Z'
}
{
  message: 'Route: /api/v1/auth/reset-password/9d24b9121b74212536fb579e3b6ba901df54b7bd21c9a292c18e29e71245581a not found',
  level: 'error',
  timestamp: '2025-02-18T18:57:19.487Z'
}
{
  message: 'Route: /api/v1/api-docs not found',
  level: 'error',
  timestamp: '2025-02-18T21:51:46.813Z'
}
{
  message: 'Route: /favicon.ico not found',
  level: 'error',
  timestamp: '2025-02-19T12:00:17.739Z'
}
{
  message: 'jwt malformed',
  level: 'error',
  timestamp: '2025-02-19T16:11:57.429Z'
}
{
  message: 'Bad Request',
  level: 'error',
  timestamp: '2025-02-19T16:21:14.127Z'
}
{
  message: 'jwt expired',
  level: 'error',
  timestamp: '2025-02-19T18:39:57.266Z'
}
{
  message: 'jwt expired',
  level: 'error',
  timestamp: '2025-02-19T18:40:08.001Z'
}
{
  message: 'Please login to access this route',
  level: 'error',
  timestamp: '2025-02-19T18:41:59.155Z'
}
{
  message: 'jwt expired',
  level: 'error',
  timestamp: '2025-02-19T19:44:01.423Z'
}
{
  message: 'Validation error: Required at "params.id"',
  level: 'error',
  timestamp: '2025-02-19T19:44:08.241Z'
}
{
  message: 'Validation error: Required at "params.id"',
  level: 'error',
  timestamp: '2025-02-19T19:44:25.422Z'
}
{
  message: '\n' +
    'Invalid `any).findMany()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\utils\\APIFeatures.ts:81:45\n' +
    '\n' +
    '  78 }\n' +
    '  79 \n' +
    '  80 async execute(): Promise<T[]> {\n' +
    '→ 81   return (this.prisma[this.model] as any).findMany({\n' +
    '         where: {\n' +
    '           limt: "1",\n' +
    '           ~~~~\n' +
    '       ?   AND?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   OR?: UserWhereInput[],\n' +
    '       ?   NOT?: UserWhereInput | UserWhereInput[],\n' +
    '       ?   id?: StringFilter | String,\n' +
    '       ?   googleId?: StringNullableFilter | String | Null,\n' +
    '       ?   name?: StringFilter | String,\n' +
    '       ?   avatar?: StringNullableFilter | String | Null,\n' +
    '       ?   email?: StringFilter | String,\n' +
    '       ?   emailVerificationToken?: StringNullableFilter | String | Null,\n' +
    '       ?   emailVerificationTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   emailVerified?: BoolFilter | Boolean,\n' +
    '       ?   password?: StringFilter | String,\n' +
    '       ?   passwordChangedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   passwordResetToken?: StringNullableFilter | String | Null,\n' +
    '       ?   passwordResetTokenExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   role?: EnumRolesFilter | Roles,\n' +
    '       ?   isActive?: BoolFilter | Boolean,\n' +
    '       ?   twoFactorAuth?: BoolFilter | Boolean,\n' +
    '       ?   OTP?: StringNullableFilter | String | Null,\n' +
    '       ?   OTPExpiresAt?: DateTimeNullableFilter | DateTime | Null,\n' +
    '       ?   createdAt?: DateTimeFilter | DateTime,\n' +
    '       ?   updatedAt?: DateTimeFilter | DateTime,\n' +
    '       ?   reviews?: ReviewListRelationFilter,\n' +
    '       ?   replies?: ReviewReplyListRelationFilter,\n' +
    '       ?   comments?: CommentListRelationFilter,\n' +
    '       ?   courses?: OrderListRelationFilter,\n' +
    '       ?   publishedCourses?: CourseListRelationFilter\n' +
    '         },\n' +
    '         select: {\n' +
    '           name: true,\n' +
    '           avatar: true\n' +
    '         },\n' +
    '         orderBy: [\n' +
    '           {\n' +
    '             name: "desc"\n' +
    '           }\n' +
    '         ],\n' +
    '         skip: 0,\n' +
    '         take: 100\n' +
    '       })\n' +
    '\n' +
    'Unknown argument `limt`. Did you mean `id`? Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-19T19:51:33.493Z'
}
{
  message: 'jwt expired',
  level: 'error',
  timestamp: '2025-02-19T20:25:43.150Z'
}
{
  message: 'Please login to access this route',
  level: 'error',
  timestamp: '2025-02-19T21:14:38.417Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findUnique()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\Auth\\Auth.Service.ts:96:36\n' +
    '\n' +
    '  93   throw new APIError("Expired session, please login again", 498);\n' +
    '  94 }\n' +
    '  95 const decoded = verifyRefreshToken(Payload);\n' +
    '→ 96 const user = await prisma.user.findUnique(\n' +
    "Can't reach database server at `lms-postgresql-8164.j77.aws-eu-central-1.cockroachlabs.cloud:26257`\n" +
    '\n' +
    'Please make sure your database server is running at `lms-postgresql-8164.j77.aws-eu-central-1.cockroachlabs.cloud:26257`.',
  level: 'error',
  timestamp: '2025-02-19T21:14:51.164Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findMany()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\User\\User.service.ts:73:46\n' +
    '\n' +
    '  70 if (JSON.stringify(orderBy) !== "{}") {\n' +
    '  71   options.orderBy = orderBy;\n' +
    '  72 }\n' +
    '→ 73 const users: IUser[] = await prisma.user.findMany({\n' +
    '       where: {\n' +
    '         name: {\n' +
    '           contains: undefined,\n' +
    '           mode: "insensitive"\n' +
    '         }\n' +
    '       },\n' +
    '       skip: 0,\n' +
    '       take: 100,\n' +
    '       orderBy: {\n' +
    '         key: "asc",\n' +
    '         ~~~\n' +
    '     ?   id?: SortOrder,\n' +
    '     ?   googleId?: SortOrder | SortOrderInput,\n' +
    '     ?   name?: SortOrder,\n' +
    '     ?   avatar?: SortOrder | SortOrderInput,\n' +
    '     ?   email?: SortOrder,\n' +
    '     ?   emailVerificationToken?: SortOrder | SortOrderInput,\n' +
    '     ?   emailVerificationTokenExpiresAt?: SortOrder | SortOrderInput,\n' +
    '     ?   emailVerified?: SortOrder,\n' +
    '     ?   password?: SortOrder,\n' +
    '     ?   passwordChangedAt?: SortOrder,\n' +
    '     ?   passwordResetToken?: SortOrder | SortOrderInput,\n' +
    '     ?   passwordResetTokenExpiresAt?: SortOrder | SortOrderInput,\n' +
    '     ?   role?: SortOrder,\n' +
    '     ?   isActive?: SortOrder,\n' +
    '     ?   twoFactorAuth?: SortOrder,\n' +
    '     ?   OTP?: SortOrder | SortOrderInput,\n' +
    '     ?   OTPExpiresAt?: SortOrder | SortOrderInput,\n' +
    '     ?   createdAt?: SortOrder,\n' +
    '     ?   updatedAt?: SortOrder,\n' +
    '     ?   reviews?: ReviewOrderByRelationAggregateInput,\n' +
    '     ?   replies?: ReviewReplyOrderByRelationAggregateInput,\n' +
    '     ?   comments?: CommentOrderByRelationAggregateInput,\n' +
    '     ?   courses?: OrderOrderByRelationAggregateInput,\n' +
    '     ?   publishedCourses?: CourseOrderByRelationAggregateInput\n' +
    '       }\n' +
    '     })\n' +
    '\n' +
    'Unknown argument `key`. Did you mean `id`? Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-19T21:17:30.567Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findMany()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\User\\User.service.ts:73:46\n' +
    '\n' +
    '  70 if (JSON.stringify(orderBy) !== "{}") {\n' +
    '  71   options.orderBy = orderBy;\n' +
    '  72 }\n' +
    '→ 73 const users: IUser[] = await prisma.user.findMany({\n' +
    '       where: {\n' +
    '         name: {\n' +
    '           contains: undefined,\n' +
    '           mode: "insensitive"\n' +
    '         }\n' +
    '       },\n' +
    '       skip: 0,\n' +
    '       take: 100,\n' +
    '       orderBy: {\n' +
    '         key: "asc",\n' +
    '         ~~~\n' +
    '     ?   id?: SortOrder,\n' +
    '     ?   googleId?: SortOrder | SortOrderInput,\n' +
    '     ?   name?: SortOrder,\n' +
    '     ?   avatar?: SortOrder | SortOrderInput,\n' +
    '     ?   email?: SortOrder,\n' +
    '     ?   emailVerificationToken?: SortOrder | SortOrderInput,\n' +
    '     ?   emailVerificationTokenExpiresAt?: SortOrder | SortOrderInput,\n' +
    '     ?   emailVerified?: SortOrder,\n' +
    '     ?   password?: SortOrder,\n' +
    '     ?   passwordChangedAt?: SortOrder,\n' +
    '     ?   passwordResetToken?: SortOrder | SortOrderInput,\n' +
    '     ?   passwordResetTokenExpiresAt?: SortOrder | SortOrderInput,\n' +
    '     ?   role?: SortOrder,\n' +
    '     ?   isActive?: SortOrder,\n' +
    '     ?   twoFactorAuth?: SortOrder,\n' +
    '     ?   OTP?: SortOrder | SortOrderInput,\n' +
    '     ?   OTPExpiresAt?: SortOrder | SortOrderInput,\n' +
    '     ?   createdAt?: SortOrder,\n' +
    '     ?   updatedAt?: SortOrder,\n' +
    '     ?   reviews?: ReviewOrderByRelationAggregateInput,\n' +
    '     ?   replies?: ReviewReplyOrderByRelationAggregateInput,\n' +
    '     ?   comments?: CommentOrderByRelationAggregateInput,\n' +
    '     ?   courses?: OrderOrderByRelationAggregateInput,\n' +
    '     ?   publishedCourses?: CourseOrderByRelationAggregateInput\n' +
    '       }\n' +
    '     })\n' +
    '\n' +
    'Unknown argument `key`. Did you mean `id`? Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-19T21:17:33.903Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findMany()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\User\\User.service.ts:73:46\n' +
    '\n' +
    '  70 if (JSON.stringify(orderBy) !== "{}") {\n' +
    '  71   options.orderBy = orderBy;\n' +
    '  72 }\n' +
    '→ 73 const users: IUser[] = await prisma.user.findMany({\n' +
    '       where: {\n' +
    '         name: {\n' +
    '           contains: undefined,\n' +
    '           mode: "insensitive"\n' +
    '         }\n' +
    '       },\n' +
    '       skip: 0,\n' +
    '       take: "1",\n' +
    '             ~~~\n' +
    '       orderBy: {\n' +
    '         createdAt: "asc"\n' +
    '       }\n' +
    '     })\n' +
    '\n' +
    'Argument `take`: Invalid value provided. Expected Int, provided String.',
  level: 'error',
  timestamp: '2025-02-19T21:18:53.584Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findMany()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\User\\User.service.ts:73:46\n' +
    '\n' +
    '  70 if (JSON.stringify(orderBy) !== "{}") {\n' +
    '  71   options.orderBy = orderBy;\n' +
    '  72 }\n' +
    '→ 73 const users: IUser[] = await prisma.user.findMany({\n' +
    '       where: {\n' +
    '         name: {\n' +
    '           contains: undefined,\n' +
    '           mode: "insensitive"\n' +
    '         }\n' +
    '       },\n' +
    '       skip: 0,\n' +
    '       take: "1",\n' +
    '             ~~~\n' +
    '       orderBy: {\n' +
    '         createdAt: "asc"\n' +
    '       }\n' +
    '     })\n' +
    '\n' +
    'Argument `take`: Invalid value provided. Expected Int, provided String.',
  level: 'error',
  timestamp: '2025-02-19T21:18:56.558Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findMany()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\User\\User.service.ts:74:46\n' +
    '\n' +
    '  71 if (JSON.stringify(orderBy) !== "{}") {\n' +
    '  72   options.orderBy = orderBy;\n' +
    '  73 }\n' +
    '→ 74 const users: IUser[] = await prisma.user.findMany({\n' +
    '       where: {\n' +
    '         name: {\n' +
    '           contains: undefined,\n' +
    '           mode: "insensitive"\n' +
    '         }\n' +
    '       },\n' +
    '       skip: 0,\n' +
    '       take: "1",\n' +
    '             ~~~\n' +
    '       orderBy: {\n' +
    '         createdAt: "asc"\n' +
    '       }\n' +
    '     })\n' +
    '\n' +
    'Argument `take`: Invalid value provided. Expected Int, provided String.',
  level: 'error',
  timestamp: '2025-02-19T21:19:27.919Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findMany()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\User\\User.service.ts:74:46\n' +
    '\n' +
    '  71 if (JSON.stringify(orderBy) !== "{}") {\n' +
    '  72   options.orderBy = orderBy;\n' +
    '  73 }\n' +
    '→ 74 const users: IUser[] = await prisma.user.findMany({\n' +
    '       where: {\n' +
    '         name: {\n' +
    '           contains: undefined,\n' +
    '           mode: "insensitive"\n' +
    '         }\n' +
    '       },\n' +
    '       skip: 0,\n' +
    '       take: 1,\n' +
    '       fields: {\n' +
    '       ~~~~~~\n' +
    '         name: true\n' +
    '       },\n' +
    '       orderBy: {\n' +
    '         createdAt: "asc"\n' +
    '       },\n' +
    '     ? cursor?: UserWhereUniqueInput,\n' +
    '     ? distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]\n' +
    '     })\n' +
    '\n' +
    'Unknown argument `fields`. Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-19T21:20:13.973Z'
}
{
  message: '\n' +
    'Invalid `prisma.user.findMany()` invocation in\n' +
    'D:\\Personal\\Node\\LMS\\backend\\src\\modules\\User\\User.service.ts:74:46\n' +
    '\n' +
    '  71 if (JSON.stringify(orderBy) !== "{}") {\n' +
    '  72   options.orderBy = orderBy;\n' +
    '  73 }\n' +
    '→ 74 const users: IUser[] = await prisma.user.findMany({\n' +
    '       where: {\n' +
    '         name: {\n' +
    '           contains: undefined,\n' +
    '           mode: "insensitive"\n' +
    '         }\n' +
    '       },\n' +
    '       skip: 0,\n' +
    '       take: 1,\n' +
    '       fields: {\n' +
    '       ~~~~~~\n' +
    '         name: true\n' +
    '       },\n' +
    '       orderBy: {\n' +
    '         createdAt: "asc"\n' +
    '       },\n' +
    '     ? cursor?: UserWhereUniqueInput,\n' +
    '     ? distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]\n' +
    '     })\n' +
    '\n' +
    'Unknown argument `fields`. Available options are marked with ?.',
  level: 'error',
  timestamp: '2025-02-19T21:20:16.316Z'
}
